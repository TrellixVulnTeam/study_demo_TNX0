# **闭包&装饰器**
## 函数应用
```python
def test1():
    print("---in test1 func---")
    
#调用函数
test1()

#引用函数
ret=test1

print(id(ret))
print(id(test1))

#通过引用调用函数
ret()
```
### 运行结果
```
---in test1 func---
140682481181152
140682481181152
---in test1 func---
```

## 闭包的解释
```python
#定义一个函数
def test(number):
    
    #在函数内部在定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数称为闭包
    def test_in(number_in):
        print("in test_in 函数，number_in is %d"%number_in)
        return number+number_in
    return test_in

#给test函数赋值，这个10就是给参数number    
ret=test(10)

#注意这里的100其实给参数number_in
print(ret(100))

#注意这里的200其实给参数number_in
print(ret(200))
```
### 运行结果
```
in test_in函数，number_in is 100
110
in test_in函数，number_in is 200
210

```
## **闭包的概念**－－－>内部函数对外部函数作用域里变量的引用（非全局变量）则称内部函数为闭包
```python 
def counter(start=0):
    count=[start]
    def incr():
        count[0]+=1
        return count[0]
    return incr
c1=counter(10)
print(c1())
print(c1())
print(c1())
```
### 运行结果
```
11
12
13
```
## 应用实例
```python
def line_conf(a,b):
    def line(x):
        return a*x+b
    return line

line1=line_conf(1,2)
line2=line_conf(3,4)
print(line1(5))
print(line2(6))
```
### 作用：
一元现性方程组，给定固定参数a、b(初始化)后，只需要给自变量就好了
<br>这么一来可以定义迭代器来玩了

## 装饰器
```python
#定义函数：完成数据包裹
def makeBold(fn):
    def wrapped():
        return "<b>"+fn()+"</b>"
    return wrapped

#定义函数：完成数据包裹
def makeItalic(fn):
    def wrapped():
        return "<i>"+fn()+"</i>"
    return wrapped
# 这一步等价于makeBold(test1)
@makeBold 
def test1():
    return "hello world-1"

@makeItalic
def test2():
    return "hello world-2"

@makeBold
@makeItalic
def test3():
    return "hello world-3"

print(test1())
print(test2())
print(test3())
```
### 运行结果
```
<b>hello world-1</b>
<i>hello world-2</i>
<b><i>hello world-3</i></b>
```
## 被装饰的函数有参数
```python
from time import ctime,sleep

def timefun(func):
    def wrappedfunc(a,b):
        print("%s called at %s"%(func.__name__,ctime()))
        print(a,b)
        func(a,b)
    return wrappedfunc

@timefun
def foo(a,b):
    print(a+b)
    
    
foo(2,8)
sleep(2)
foo(4,6)
```
## 不定参数的装饰器
```python 
from time import ctime,sleep

def timefun(func):
    def wrappedfunc(*args,**kwargs):
        print("%s called at %s"%(func.__name__,ctime()))
        func(*args,**kwargs)
    return wrappedfunc

@timefun
def foo(a,b,c):
    print(a+b+c)
    
foo(1,3,5)
sleep(2)
foo(2,4,6)
```
### 运行结果
```
foo called at Wed May 29 19:04:46 2019
9
foo called at Wed May 29 19:04:48 2019
12
```

## 装饰器中有return
```python 
from time import ctime,sleep

def timefun(func):
    def wrappedfunc():
        print("%s called at %s"%(func.__name__,ctime()))
        func()
    return wrappedfunc

@timefun
def foo():
    print('I am foo')
    
@timefun
def getInfo():
    return '---hello---'

foo()
sleep(2)
foo()


print(getInfo())




#输出结果
foo called at Wed May 29 19:12:04 2019
I am foo
foo called at Wed May 29 19:12:06 2019
I am foo
getInfo called at Wed May 29 19:12:06 2019
None

```

对上代码修改
```python
def timefun(func):
    def wrappedfunc():
        print("%s called at %s"%(func.__name__,ctime()))
        ret=func()  #保存返回来的hello
        return ret   #把hello返回给调用函数
    return wrappedfunc

@timefun
def foo():
    print('I am foo')
    
@timefun
def getInfo():
    return '---hello---'

foo()
sleep(2)
foo()


print(getInfo())


# 测试结果
foo called at Wed May 29 19:17:36 2019
I am foo
foo called at Wed May 29 19:17:38 2019
I am foo
getInfo called at Wed May 29 19:17:38 2019
---hello---

```

## 装饰器带参数，在原有装饰器的基础上，设置外部变量
```python 
from time import ctime, sleep

def timefun_arg(pre="hello"):
    def timefun(func):
        def wrappedfunc():
            print("%s called at %s %s"%(func.__name__, ctime(), pre))
            return func()
        return wrappedfunc
    return timefun

@timefun_arg("itcast")
def foo():
    print("I am foo")

@timefun_arg("python")
def too():
    print("I am too")

foo()
sleep(2)
foo()

too()
sleep(2)
too()
```
### 等价于
**foo()==timefun_arg("itcast")(foo)()**